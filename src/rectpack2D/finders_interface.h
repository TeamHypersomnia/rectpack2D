#pragma once
#include <memory>
#include "empty_spaces.h"
#include "best_bin_finder.h"
#include "empty_space_allocators.h" // IWYU pragma: export

namespace rectpack2D {
	template <class empty_spaces_type>
	using output_rect_t = typename empty_spaces_type::output_rect_type;

	template <class F, class G>
	struct finder_input {
		const int max_bin_side;
		const int discard_step;
		F handle_successful_insertion;
		G handle_unsuccessful_insertion;
		const flipping_option flipping_mode;
	};

	template <class F, class G>
	auto make_finder_input(
		const int max_bin_side,
		const int discard_step,
		F&& handle_successful_insertion,
		G&& handle_unsuccessful_insertion,
		const flipping_option flipping_mode
	) {
		return finder_input<F, G> { 
			max_bin_side, 
			discard_step, 
			std::forward<F>(handle_successful_insertion),
			std::forward<G>(handle_unsuccessful_insertion),
			flipping_mode
		};
	};

	/*
		Finds the best packing for the rectangles,
		just in the order that they were passed.
	*/

	template <class empty_spaces_type, class Subjects, class F, class G>
	rect_wh find_best_packing_dont_sort(
		Subjects& subjects,
		const finder_input<F, G>& input
	) {
		// Works with C arrays as well.
		using iterator_type = decltype(std::begin(subjects));
		using order_type = rectpack2D::span<iterator_type>;

		order_type ord(std::begin(subjects), std::end(subjects));

		return find_best_packing_impl<empty_spaces_type, order_type>(
			[=](auto callback) { callback(ord); },
			[]() {},
			input,
			ord
		);
	}


	/*
		Finds the best packing for the rectangles.
		Accepts a list of predicates able to compare two input rectangles.
	   
		The function will try to pack the rectangles in all orders generated by the predicates,
		and will only write the x, y coordinates of the best packing found among the orders.
	*/

	template <class empty_spaces_type, class Subjects, class F, class G, class Comparator, class... Comparators>
	rect_wh find_best_packing(
		Subjects& subjects,
		const finder_input<F, G>& input,

		Comparator comparator,
		Comparators... comparators
	) {
		using rect_type = output_rect_t<empty_spaces_type>;
		using order_type = rectpack2D::span<rect_type**>;

		std::size_t count_valid_subjects = 0;

		// Allocate space assuming no rectangle has an area of zero.
		// We fill orders with valid rectangles only.
		auto orders = std::make_unique<rect_type*[]>(2 * std::size(subjects));

		for (auto& s : subjects) {
			auto& r = s.get_rect();

			if (r.area() == 0) {
				continue;
			}

			orders[count_valid_subjects++] = std::addressof(r);
		}

		auto orders_begin = orders.get();
		auto orders_separator = orders_begin + count_valid_subjects;
		auto orders_end = orders_separator + count_valid_subjects;

		return find_best_packing_impl<empty_spaces_type, order_type>(
			// Predicates can be expensive-to-copy objects such as std::function,
			// so capture them by reference just to be sure.
			[=, &comparator, &comparators...](auto callback) {
				auto make_order = [=](auto predicate) {
					std::sort(orders_begin, orders_separator, predicate);
					callback({orders_begin, orders_separator});
				};

				make_order(comparator);
				(make_order(comparators), ...);
			},
			[=]() { std::copy(orders_begin, orders_separator, orders_separator); },
			input,
			{ orders_separator, orders_end }
		);
	}

	/*
		Finds the best packing for the rectangles.
		Provides a list of several sensible comparison predicates.
	*/

	template <class empty_spaces_type, class Subjects, class F, class G>
	rect_wh find_best_packing(
		Subjects& subjects,
		const finder_input<F, G>& input
	) {
		using rect_type = output_rect_t<empty_spaces_type>;

		return find_best_packing<empty_spaces_type>(
			subjects,
			input,

			[](const rect_type* const a, const rect_type* const b) {
				return a->area() > b->area();
			},
			[](const rect_type* const a, const rect_type* const b) {
				return a->perimeter() > b->perimeter();
			},
			[](const rect_type* const a, const rect_type* const b) {
				return std::max(a->w, a->h) > std::max(b->w, b->h);
			},
			[](const rect_type* const a, const rect_type* const b) {
				return a->w > b->w;
			},
			[](const rect_type* const a, const rect_type* const b) {
				return a->h > b->h;
			}
		);
	}
}
