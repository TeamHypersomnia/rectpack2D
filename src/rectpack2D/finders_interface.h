#pragma once
#include <optional>
#include <vector>
#include <array>
#include <variant>
#include <memory>
#include <algorithm>

#include "insert_and_split.h"
#include "empty_spaces.h"
#include "empty_space_allocators.h"

#include "best_bin_finder.h"

namespace rectpack2D {
	template <class empty_spaces_type>
	using output_rect_t = typename empty_spaces_type::output_rect_type;

	template <class F, class G>
	struct finder_input {
		const int max_bin_side;
		const int discard_step;
		F handle_successful_insertion;
		G handle_unsuccessful_insertion;
		const flipping_option flipping_mode;
	};

	template <class F, class G>
	auto make_finder_input(
		const int max_bin_side,
		const int discard_step,
		F&& handle_successful_insertion,
		G&& handle_unsuccessful_insertion,
		const flipping_option flipping_mode
	) {
		return finder_input<F, G> { 
			max_bin_side, 
			discard_step, 
			std::forward<F>(handle_successful_insertion),
			std::forward<G>(handle_unsuccessful_insertion),
			flipping_mode
		};
	};

	/*
		Finds the best packing for the rectangles,
		just in the order that they were passed.
	*/

	template <class empty_spaces_type, class Subjects, class F, class G>
	rect_wh find_best_packing_dont_sort(
		Subjects& subjects,
		const finder_input<F, G>& input
	) {
		// Works with C arrays as well.
		using iterator_type = decltype(std::begin(subjects));
		using order_type = std::pair<iterator_type, iterator_type>;

		return find_best_packing_impl<empty_spaces_type, order_type>(
			[&subjects](auto callback) { callback(order_type(std::begin(subjects), std::end(subjects))); },
			input
		);
	}


	/*
		Finds the best packing for the rectangles.
		Accepts a list of predicates able to compare two input rectangles.
	   
		The function will try to pack the rectangles in all orders generated by the predicates,
		and will only write the x, y coordinates of the best packing found among the orders.
	*/

	template <class empty_spaces_type, class Subjects, class F, class G, class Comparator, class... Comparators>
	rect_wh find_best_packing(
		Subjects& subjects,
		const finder_input<F, G>& input,

		Comparator comparator,
		Comparators... comparators
	) {
		using rect_type = output_rect_t<empty_spaces_type>;
		using order_type = std::pair<rect_type**, rect_type**>;

		constexpr auto count_orders = 1 + sizeof...(Comparators);
		std::size_t count_valid_subjects = 0;

		// Allocate space assuming no rectangle has an area of zero.
		// The actual size is adjusted later.
		auto orders = std::make_unique<rect_type*[]>(count_orders * std::size(subjects));

		for (auto& s : subjects) {
			auto& r = s.get_rect();

			if (r.area() == 0) {
				continue;
			}

			orders[count_valid_subjects++] = std::addressof(r);
		}

		// Cut off any potentially unused rectangle pointers at the end.
		const auto orders_end = orders.get() + (count_orders * count_valid_subjects);

		for (auto it = orders.get() + count_valid_subjects; it != orders_end; it += count_valid_subjects) {
			std::copy(orders.get(), orders.get() + count_valid_subjects, it);
		}

		std::size_t f = 0;

		auto make_order = [&f, &orders, &count_valid_subjects](auto& predicate) {
			std::sort(
				orders.get() + (f * count_valid_subjects),
				orders.get() + ((f + 1) * count_valid_subjects),
				predicate
			);
			++f;
		};

		make_order(comparator);
		(make_order(comparators), ...);


		return find_best_packing_impl<empty_spaces_type, order_type>(
			[count_valid_subjects, &orders, orders_end](auto callback) {
				for (auto it = orders.get(); it != orders_end; it += count_valid_subjects) {
					callback(order_type(it, it + count_valid_subjects));
				}
			},
			input
		);
	}

	/*
		Finds the best packing for the rectangles.
		Provides a list of several sensible comparison predicates.
	*/

	template <class empty_spaces_type, class Subjects, class F, class G>
	rect_wh find_best_packing(
		Subjects& subjects,
		const finder_input<F, G>& input
	) {
		using rect_type = output_rect_t<empty_spaces_type>;

		return find_best_packing<empty_spaces_type>(
			subjects,
			input,

			[](const rect_type* const a, const rect_type* const b) {
				return a->area() > b->area();
			},
			[](const rect_type* const a, const rect_type* const b) {
				return a->perimeter() > b->perimeter();
			},
			[](const rect_type* const a, const rect_type* const b) {
				return std::max(a->w, a->h) > std::max(b->w, b->h);
			},
			[](const rect_type* const a, const rect_type* const b) {
				return a->w > b->w;
			},
			[](const rect_type* const a, const rect_type* const b) {
				return a->h > b->h;
			}
		);
	}
}
